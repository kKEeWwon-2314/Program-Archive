import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;

import javax.swing.*;
import java.util.ArrayList;

public class MyGraphics extends JPanel implements MouseListener {

    SudokuSolver sudoku;
    boolean[][] textColours;
    int unit = (500 / 9);
    int WIDTH = 495;
    int HEIGHT = 495;
    int HEIGHT_OFFSET = 28; // Corrects for the fact that the window height includes the bar at the top
    
    int WAIT_TIME = 500; // Time to pause after changing a cell, in milliseconds

    public MyGraphics(SudokuSolver s) {
        // setup code from main method
        JFrame frame = new JFrame("Sudoku Solver");
        frame.add(this);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setBounds(0, 0, WIDTH, HEIGHT + HEIGHT_OFFSET);
        frame.setVisible(true);
        
        // Constructor
        sudoku = s;
        addMouseListener(this);

        // Record which cells were provided as the puzzle's inital state - we will draw those cells in black,
        // and the ones generated by our AI in gray
        textColours = new boolean[9][9];
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (sudoku.puzzle[i][j] > 0) {
                    textColours[i][j] = true;
                }
                else {
                    textColours[i][j] = false;
                }
            }
        }
    }

    // This method, with this exact name, parameter and return type, overwrites the paint() method in JPanel
    // (This is where the drawing actually happens)
    public void paint(Graphics g) {
        // clear previous
        super.paint(g);

        // Code to draw things in the window goes here
        Graphics2D g2 = (Graphics2D) g; // Convert to a Graphics2D object, because Graphics2D has improved functionality

        // Draw grid lines
        g2.setColor(Color.BLACK);

        // Vertical grid lines
        for (int i = 0; i < 9; i++) {
            if (((i + 1) % 3) == 0) {
                g2.setStroke(new BasicStroke(3));
            }
            else {
                g2.setStroke(new BasicStroke(1));
            }

            int x = (i + 1) * unit;
            g2.drawLine(x, 0, x, HEIGHT);
        }
        // Horizontal grid lines
        for (int i = 0; i < 9; i++) {
            if (((i + 1) % 3) == 0) {
                g2.setStroke(new BasicStroke(3));
            }
            else {
                g2.setStroke(new BasicStroke(1));
            }
            
            int y = ((i + 1) * unit);
            g2.drawLine(0, y, WIDTH, y);
        }

        g.setFont(new Font("Lora", Font.PLAIN, 32));
        // Draw current puzzle state
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (textColours[i][j]) {
                    g2.setColor(Color.BLACK);
                }
                else {
                    g2.setColor(Color.GRAY);
                }
                if (sudoku.puzzle[i][j] > 0) {
                    g2.drawString(sudoku.puzzle[i][j].toString(), (j * unit) + (unit / 3), ((i + 1) * unit) - (unit / 3));
                }
            }
        }
    }

    public void updateBoard() {
        repaint();
        try {
            Thread.sleep(WAIT_TIME);
        }
        catch(Exception e) {
            System.out.println("Error, could not call Thread.sleep");
        }
    }

    @Override
    public void mouseClicked(MouseEvent e) {}
    @Override
    public void mousePressed(MouseEvent e) {}
    @Override
    public void mouseReleased(MouseEvent e) {}
    @Override
    public void mouseEntered(MouseEvent e) {}
    @Override
    public void mouseExited(MouseEvent e) {}
}